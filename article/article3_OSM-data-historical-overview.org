#+TITLE: OSM data historical overview: what is the OSM API evolution through time?
#+AUTHOR: Damien Garaud <damien.garaud@oslandia.com>, RaphaÃ«l Delhome <raphael.delhome@oslandia.com>

# Common introduction for articles of the OSM-data-quality series
At [Oslandia](http://oslandia.com/), we like working with Open Source tool
projects and handling Open (geospatial) Data. In this article series, we will
play with the [OpenStreetMap](https://www.openstreetmap.org/) (/OSM/) map and
subsequent data. Here comes the third article of this series, dedicated to the
chronological overview of OSM data.

* How to get the data

** Build our own OSM data sample

:warning: to be checked !!!

First of all we have to recover a dataset. Two major solutions exist: either we
can dowload a regional area on [[http://download.geofabrik.de/][Geofabrik]] (/e.g./ a continent, a country, or
even a sub-region, like Aquitaine), or we can extract another area through a
bounding box drawn directly with OpenStreetMap [[https://www.openstreetmap.org/#map=10/45.0000/0.0000][API]] with [[http://osmcode.org/osmium-tool/][osmium-tool]]. Even if the
former solution is easier, we detail here the latter one in order to use a
smaller data set.

*Note*: =osmium-tool= is available as a package in the Debian GNU/Linux
distribution.

Let us work with a bounding box capture focused on Bordeaux, a medium-sized
French city. We use the following bounding box coordinates: the top-left corner
is at ={44.9335, -0.7179}= whilst the bottom-right corner is at ={44.7216,
-0.4134}=. These coordinates seem quite weird, however there are just
hand-made, by successive zooms in the OSM API.

#+CAPTION: Hand-made bounding box on Bordeaux city (France)
#+NAME: fig:osm-bb-example
[[./../figs/osm_boundingbox_example.png]]

They are integrated in the following JSON configuration file:

#+BEGIN_SRC js
  {
    "extracts": [
      {
        "output": "region-history.osh.pbf",
        "output_format": "osh.pbf",
        "description": "extract OSM history for a specific region",
        "bbox": {"left": -0.7179,
                 "right": -0.4134,
                 "top": 44.9335,
                 "bottom": 44.7216}
      }
    ],
    "directory": "/path/to/outputdir/"
  }
#+END_SRC

And this JSON file is used by osmium to build a standard /pbf/ file:

#+BEGIN_SRC shell
osmium extract --with-history --config=region.json latest-planet.osh.pbf
#+END_SRC

The =--with-history= flag is important. We want to study the temporal evolution
of some OSM entities, the number of contributions, and check some specific OSM
entities such as nodes, ways or relations and get their history. The only thing
to do is to set the output file name, let say it will be
=bordeaux-metropole.osh.pbf= in our case.

** Extract OSM data history

At this point, we have a /pbf/ file that contain every OSM element versions
through time. We still have to write them into a /csv/ file. Here we use
[[http://docs.osmcode.org/pyosmium/latest/index.html][pyosmium]] (see previous article).

This operation can be done through a simple Python file. First we have to
import the useful libraries, that are pandas (to handle dataframes and /csv/
files) and pyosmium. Then, we define a small OSM data handler, that saves every
nodes into the =elemtimeline= attribute (/i.e./ a list). This example is
limited to node for a sake of concision, however this class is easily
extensible to other OSM objects. We can observe that several node attributes
are recorded: the element type ("node" for nodes, of course!), ID, version in
the history, if it is currently visible on the API, timestamp (when the version
has been set), user ID, change set ID and the number of associated tags. These
attributes are also available for ways and relations, letting the chance to put
a little more abstract in this class definition!

#+BEGIN_SRC ipython :session osm :exports both                                   
  import pyosmium as osm
  import pandas as pd

  class TimelineHandler(osm.SimpleHandler):
      def __init__(self):
          osm.SimpleHandler.__init__(self)
          self.elemtimeline = []
      
      def node(self, n):
          self.elemtimeline.append(["node", 
                                    n.id, 
                                    n.version, 
                                    n.visible, 
                                    pd.Timestamp(n.timestamp), 
                                    n.uid, 
                                    n.changeset, 
                                    len(n.tags)])
#+END_SRC

An instance of this class can be created so as to save OSM nodes within the
bordeaux metropole area. We pass the input file name to the =apply_file=
procedure, that scans the input file and fills the handler list
accordingly. After that we just have to transform the list into a pandas
DataFrame, to make further treatments easier.

#+BEGIN_SRC ipython :session osm :exports both
  tlhandler = TimelineHandler()
  tlhandler.apply_file("bordeaux-metropole.osh.pbf")
  colnames = ['type', 'id', 'version', 'visible', 'ts', 'uid', 'chgset', 'ntags']
  elements = pd.DataFrame(tlhandler.elemtimeline, columns=colnames)
  elements = elements.sort_values(by=['type', 'id', 'ts'])
  elements.head(10)
#+END_SRC

#+RESULTS:
#+begin_example
#+end_example

With the help of pandas library, to save the file into /csv/ format is straightforward:
#+BEGIN_SRC ipython :session osm :exports both
  elements.to_csv("bordeaux-metropole.csv", date_format='%Y-%m-%d %H:%M:%S')
#+END_SRC

At this point, the OSM data history is available in a /csv/ file format, with a
whole set of attributes that will be useful to describe the data.

* How do the OSM API evolve through time?

** A simple procedure to build dated OSM histories

From the OSM data history we can recover the current state of OSM data (or more
precisely, the API state at the data extraction date). The only step that is
needed is to select the up-to-date OSM objects, /i.e./ those with the last
existing version.

#+BEGIN_SRC ipython :session osm :exports both
  def updatedelem(data):
      updata = data.groupby(['elem','id'])['version'].max().reset_index()
      return pd.merge(updata, data, on=['id','version'])
  uptodate_elem = updatedelem(elements)
  uptodate_elem.shape
#+END_SRC

#+RESULTS:
#+begin_example
#+end_example

This seem to be a quite useless function: we could have found directly such
data on GeoFabrik website, isn't it? ... Well, it is not useless. As an
extension of this first procedure, we propose a simple but seminal procedure
called =datedelems= that allows us to get the OSM API picture given a specific
date:

#+BEGIN_SRC ipython :session osm :exports both
  def datedelems(history, date):
      datedelems = (history.query("ts <= @date")
                    .groupby(['elem','id'])['version']
                    .max()
                    .reset_index())
      return pd.merge(datedelems, history, on=['elem','id','version'])
  oldelem = datedelems(elements, "2014-01-01")
  oldelem.shape
#+END_SRC

We can notice in this function that pandas allows to express queries in a
SQL-like mode, a very useful practice to explore data!

#+RESULTS:
#+begin_example
#+end_example

As a corollary we can build some time series aiming to describe the evolution
of the API in terms of OSM objects (nodes, ways, relations) or users.

** How to get the OSM API evolution?

For instance, what if we consider OSM API state month after month? What is the
temporal evolution of node, way, or relation amounts? The following procedure
helps us to describe the OSM API at a given date: how many node/way/relation
there are, how many user have contributed, how many change sets have been
opened. Further statistics may be designed, in the same manner.

#+BEGIN_SRC ipython :session osm :exports both
  def osm_stats(osm_history, timestamp):
      osmdata = datedelems(osm_history, timestamp)    
      nb_nodes = len(osmdata.query('elem=="node"'))
      nb_ways = len(osmdata.query('elem=="way"'))
      nb_relations = len(osmdata.query('elem=="relation"'))
      nb_users = osmdata.uid.nunique()
      nb_chgsets = osmdata.chgset.nunique()
      return [nb_nodes, nb_ways, nb_relations, nb_users, nb_chgsets]
  oldstats = osm_stats(elements, "2014-01-01")
  oldstats
#+END_SRC

By designing a last function, we can obtain a pandas dataframe that summarizes
basic statistics at regular timestamps: in this example, we focus on monthly
evaluations, however everything is possible... A finner analysis is possible,
by taking advantage of pandas time series capabilities.

#+BEGIN_SRC ipython :session osm :exports both
  def osm_chronology(history, start_date, end_date):
      timerange = pd.date_range(start_date, end_date, freq="1M").values 
      osmstats = [osm_stats(history, str(date)) for date in timerange]
      osmstats = pd.DataFrame(osmstats, index=timerange,
                              columns=['n_nodes', 'n_ways', 'n_relations',
                                       'n_users', 'n_chgsets'])
      return osmstats
#+END_SRC

These developments open further possibilities. Areas are comparable through
their history. A basic hypothesis could be: some areas have been built faster
than others, *e.g.* urban areas /vs/ desert areas. To investigate on the
evolutions of their OSM objects appears as a very appealing way to address this
issue!

** What about the Bordeaux area?

To illustrate the previous points, we can call the =osm_chronology= procedure
to Bordeaux-related OSM data. We can study the last 10 years, as an example:

#+BEGIN_SRC ipython :session osm :exports both
  chrono_data = osm_chronology(elements, "2007-01-01", "2017-01-01")
  chrono_data.iloc[ [:10,-10:] , ]
#+END_SRC

#+RESULTS:
#+begin_example
#+end_example

The figure below describe the evolution of nodes, ways and relations around
Bordeaux between 2007 and 2017. We can see that there was a clear rise of OSM
platform after a few years...

#+CAPTION: Amount of OSM objects in the area of Bordeaux (France)
#+NAME: fig:bm-chronology
[[./../figs/bordeaux-metropole-chronology-objects.png]]

We can also measure the number of active users in this area, at the same period. 

#+CAPTION: Amount of OSM objects in the area of Bordeaux (France)
#+NAME: fig:bm-chronology
[[./../figs/bordeaux-metropole-chronology-users.png]]

This last point is necessarily uncomplete if we consider only local
data. Active users all around the world are not those who have collaborated for
this specific region. However the change set and user statistics for
full-planet dumps exist, if you are interested in going deeper about this point!

Before concluding this article, here is provided a comparison between OSM node
amounts in several french areas. We just mention small areas, to keep the
evaluation short: Upper Normandy, a roughly rural environment with some
medium-sized cities (Rouen, Le Havre, Evreux...), Corsica, an montainous island
near to mainland France and French Guiana, an overseas area mainly composed of
jungle:

#+CAPTION: Amount of OSM nodes in several french areas
#+NAME: fig:multiarea-chronology
[[./../figs/multi-area-chronology.png]]

* Conclusion

After this third article dedicated to OSM data analysis, we hope you will be OK
with OSM data parsing. In next article, we will focus to another parsing task:
the tag set exploration.
